table:
  name: 'MsIntEventInboxMsg'
  description: 'An inbox for incoming integration events that have been publish by external systems.'
  tableUsageNo: 1
  domainType: 10
  headerTable: 'HdMessageStore'
  genericComponents:
    tableType: 6
    groupId: 47a738e9-4dcb-41bc-8fcc-bb1699c6b097
    visumLevel: 1
    cacheLevel: 1
    physicalDelete: true
    uiTableDescription:
    - english:
        formTitle: 'Event Inbox'
        helpText: 'An inbox for incoming integration events that have been publish by external systems.'
    - german:
        formTitle: 'Ereigniseingangspostfach'
        helpText: 'Einganspostfach für Ereignisse welche von externen Systemen veröffentlicht werden'
    - french:
        formTitle: 'Boîte de réception'
        helpText: 'An inbox for incoming integration events that have been publish by external systems.'
    - italian:
        formTitle: 'Casella di posta in arriv'
        helpText: 'An inbox for incoming integration events that have been publish by external systems.'
  columns:
  - name: 'Topic'
    description: 'The topic this event belongs to. This should be a fully qualified name.'
    genericControls:
      isNoUpdate: true
  - name: 'CorrelationId'
    description: 'The correlationId to correlate an event with other events that happened in the same event cascade, starting at the frontend, when a user enters a command to the system. The correlationId is propagated together with the ProcessName from the beginning until the end.'
    genericControls:
      isNoUpdate: true
  - name: 'RequestId'
    description: 'The id of the last API call that was made in a chain of events and API calls. \r\nThis behaves similarly to the correlationId except there is a new requestId with every  API command or query made.\r\nIn cases where no API call was made, this can be set equal to  the jobId or processId for background processes or similar.'
    genericControls:
      isNoUpdate: true
  - name: 'IsRealTime'
    description: 'Whether the first event in the cascade was triggered real-time as part of an active  business process. False means, the event is a replay-event or another type of artificially generated event, For example by polling entities and observing whether their state changed, and if so, inferring events that might have happened since the  last poll. Such events have no guarantee to arrive in the order in which they occurred in the source system. This should only be set to false when interacting with legacy parts of the system that don''t naturally provide events.'
    genericControls:
      isNoUpdate: true
  - name: 'IsTombStone'
    description: 'True if this is a so-called "tomb stone event" which indicates that an entity has been deleted permanently so that any occurrence of the entity can be deleted from downstream systems. It indicates that the event history for this entity can be moved to an archive and removed from all transactional systems.\r\nOnce a tomb stone event is published to the broker, all the past events referring to the same key will be deleted at some (maybe undefined yet) point in the future.\r\nWhen this happens, only the tomb stone event should be left in order to indicate that "there was something".\r\nThe archived events could be encrypted with a public key while the private key for decryption remains in a secure place that nobody can access except under highly regulated circumstances.'
    genericControls:
      isNoUpdate: true
  - name: 'Offset'
    description: 'This indicates the position of a message in a stream that can be used to continue consumation of a stream where the consumer left last time. Although the particular mechanisms are different, they have a similar purpose.\r\n\r\nBecause there are inherently different semantics, depending on broker technology, you should be careful interpreting this number.\r\n\r\nIn Kafka, this is called offset, which is the zero-based integer sequence number of an event in a partition (partitions are created per topic). Kafka maintains the offset every consumer. It is updated when the consumer commits. Auto-commit is possible.\r\n\r\nIn RabbitMQ, the sequence number indicates the position of a message in a queue.  The position of a consumer is maintained by the consumer itself with a StreamCursor.\r\n\r\nThis field is only found in the inbox, not in the outbox because it is only relevant for  consumers.'
    genericControls:
      isNoUpdate: true
  - name: 'EventTime'
    description: 'The time when the event occurred in the source system.'
    genericControls:
      isNoUpdate: true
  - name: 'PublishTime'
    description: 'The timestamp when the producer started producing the message to the broker.'
    genericControls:
      isNoUpdate: true
  - name: 'LogAppendTime'
    description: 'The time when the message was successfully appended to the log or stream in the broker.\r\n\r\nKafka sets this value.\r\nRabbitMQ does not set this by default but there is a plugin for it.'
    genericControls:
      isNoUpdate: true
  - name: 'Branch'
    description: 'The branch is like a sub-tenant and relevant routing and authorization information.\r\nWhen there are branch-specific consumers (for example fintechs), that consumer shall only see messages of a specific branch.\r\n\r\nWhen there is no branch, a suitable value like ALL or BANK should be used. Hence, the branch should always be set to indicate the target destination.'
    genericControls:
      isNoUpdate: true
  - name: 'Process'
    description: 'Name of the business process or use case that caused a chain of events to happen, including this one. The prcoess name is propagated in a stream processing pipeline along with the correlationId.\r\nThe process name is usually determined at the boundary when a human user enters a command or when an automated time-based trigger causes an event cascade.\r\nThis is typically determined by the first application-layer service that was hit when answering the request of a user.'
    genericControls:
      isNoUpdate: true
  - name: 'Producer'
    description: 'The name of the producer application or service.'
    genericControls:
      isNoUpdate: true
  - name: 'InitiatorApp'
    description: 'The name of the application that caused the event to be triggered.\r\nThis is the application which has initiated the first command or query in a cascade of events, the same time when the correlationId should be created. Both propagate through the whole cascade from beginning until the end.'
    genericControls:
      refTable: 'AsExternalApplication'
      refField: 'ApplicationCode'
      isNoUpdate: true
  - name: 'Initiator'
    description: 'The user (human or machine) that caused the event to happen, directly or indirectly by sending a command and which might have caused a cascade of events to happen, including this one.'
    genericControls:
      isNoUpdate: true
  - name: 'KeyFormat'
    description: 'The format of the key, such as JSON, Avro, or Text'
    genericControls:
      isNoUpdate: true
  - name: 'ValueFormat'
    description: 'The format of the value (payload), such as JSON, Avro, or Text'
    genericControls:
      isNoUpdate: true
  - name: 'Type'
    description: 'The type of the event.\r\nThis information is typically attached to a header of messages and used for deserializing. It is therefore recommended to put event type and version of the event schema in the name.\r\n\r\nThe events are optionally defined in AsIntEventType, but not referenced as a foreign key because then event type alone might not be unique,'
    genericControls:
      isNoUpdate: true
  - name: 'MessageKey'
    description: 'The key of the message that is used for partitioning and routing by the event broker.\r\nOften it is the id of the entity or an aggregate which the event is about, so that all the events of a particular entity end up in the same partition so that they can be consumed by the same consumer in FIFO order.\r\nIf such an entityId  is taken, the key will usually be only a few bytes. But event brokers like Kafka and RabbitMQ support message sizes of at least 1 MB or 128 KB respectively.\r\nWhen the key is missing, the message will be sent randomly to a partition.\r\nThe assignment to a partition is relevant for load balancing in a microservice architecture with a cluster of microservice nodes that distribute the workload. By routing messages with the same key to the same node every time it is possible that the same microservice sees all the events related to the same key.\r\nFor example, a good option for the key could be the PartnerId such that all events having something to do with a particula partner end up in the same partition.'
    genericControls:
      isNoUpdate: true
  - name: 'Headers'
    description: 'Contains any additional metadata that is not covered by the standard set of fields.\r\nThis is a newline (\n) separated list of key:value pairs. Keys should be unique. Like:\r\n\r\nkey1:value1\r\nkey2:value2\r\nkey3:value3'
    genericControls:
      isNoUpdate: true
  - name: 'Value'
    description: 'The payload of the message in arbitrary format as specified by the Format field.\r\nThe type is image because varbinary can be too small with maximum 8 KB.\r\nEvent brokers like Kafka and RabbitMQ support more, at  east 1 MB or 128 KB respectively.'
    genericControls:
      isNoUpdate: true